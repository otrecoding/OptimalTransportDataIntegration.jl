<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Quickstart · OptimalTransportDataIntegration</title><meta name="title" content="Quickstart · OptimalTransportDataIntegration"/><meta property="og:title" content="Quickstart · OptimalTransportDataIntegration"/><meta property="twitter:title" content="Quickstart · OptimalTransportDataIntegration"/><meta name="description" content="Documentation for OptimalTransportDataIntegration."/><meta property="og:description" content="Documentation for OptimalTransportDataIntegration."/><meta property="twitter:description" content="Documentation for OptimalTransportDataIntegration."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>OptimalTransportDataIntegration</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Quickstart</a><ul class="internal"><li><a class="tocitem" href="#Helper-functions"><span>Helper functions</span></a></li></ul></li><li><a class="tocitem" href="joint_ot_within_base/">Transport within a data source</a></li><li><a class="tocitem" href="joint_ot_between_bases/">Transport between data sources</a></li><li><a class="tocitem" href="learning/">Machine Learning</a></li><li><a class="tocitem" href="simulations/">Numerical experiments</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Quickstart</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Quickstart</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/otrecoding/OptimalTransportDataIntegration.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/otrecoding/OptimalTransportDataIntegration.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="OptimalTransportDataIntegration.jl"><a class="docs-heading-anchor" href="#OptimalTransportDataIntegration.jl">OptimalTransportDataIntegration.jl</a><a id="OptimalTransportDataIntegration.jl-1"></a><a class="docs-heading-anchor-permalink" href="#OptimalTransportDataIntegration.jl" title="Permalink"></a></h1><article><details class="docstring" open="true"><summary id="OptimalTransportDataIntegration.DataParameters"><a class="docstring-binding" href="#OptimalTransportDataIntegration.DataParameters"><code>OptimalTransportDataIntegration.DataParameters</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct DataParameters</code></pre><p>Scenario parameters for synthetic data generation.</p><p>Specifies all hyperparameters controlling data generation for both discrete and continuous covariate settings. Includes sample sizes, covariate distributions, effect sizes, noise levels, and outcome category probabilities. Can be persisted to/from JSON for reproducible experiments.</p><p><strong>Fields</strong></p><ul><li><code>nA::Int</code>: Sample size for base A; default: 1000</li><li><code>nB::Int</code>: Sample size for base B; default: 1000</li><li><code>mA::Vector{Float64}</code>: Mean vector for base A covariates (MVN); default: [0.0, 0.0, 0.0]</li><li><code>mB::Vector{Float64}</code>: Mean vector for base B covariates (MVN); default: [1.0, 1.0, 0.0]</li><li><code>covA::Matrix{Float64}</code>: Covariance matrix for base A covariates; default: 3×3 with diag=1, off-diag=0.2</li><li><code>covB::Matrix{Float64}</code>: Covariance matrix for base B covariates; default: 3×3 with diag=1, off-diag=0.2</li><li><code>aA::Vector{Float64}</code>: Effect sizes (regression coefficients) for base A outcomes; default: [1.0, 1.0, 1.0]</li><li><code>aB::Vector{Float64}</code>: Effect sizes (regression coefficients) for base B outcomes; default: [1.0, 1.0, 1.0]</li><li><code>r2::Float64</code>: Coefficient of determination (signal-to-noise ratio); default: 0.6 (higher = stronger signal)</li><li><code>pA::Vector{Vector{Float64}}</code>: Category probabilities for base A categorical covariates (one vector per dimension)<ul><li>default: [[0.5, 0.5], [1/3, 1/3, 1/3], [0.25, 0.25, 0.25, 0.25]]</li><li>For discrete generator: multinomial probabilities</li><li>For continuous generator: unused</li></ul></li><li><code>pB::Vector{Vector{Float64}}</code>: Category probabilities for base B categorical covariates (one vector per dimension)<ul><li>default: [[0.8, 0.2], [1/3, 1/3, 1/3], [0.25, 0.25, 0.25, 0.25]]</li><li>For discrete generator: multinomial probabilities</li><li>For continuous generator: unused</li></ul></li></ul><p><strong>Usage</strong></p><p>Create with defaults:</p><pre><code class="language-julia hljs">params = DataParameters()</code></pre><p>Customize selected fields:</p><pre><code class="language-julia hljs">params = DataParameters(nA=500, nB=500, r2=0.8, mB=[2.0, 2.0, 0.0])</code></pre><p><strong>Key Concepts</strong></p><ul><li><strong>Covariate Shift</strong>: Controlled by different mA/mB (continuous) or pA/pB (discrete)</li><li><strong>Sample Imbalance</strong>: Controlled by different nA/nB</li><li><strong>Signal Strength</strong>: Controlled by r2 (0 = pure noise, 1 = perfect signal)</li><li><strong>Effect Sizes</strong>: aA/aB control how strongly outcomes depend on covariates</li><li><strong>Bases Design</strong>: Base A has outcome Z, Base B has outcome Y; X covariates overlap</li></ul><p><strong>See Also</strong></p><ul><li><code>DiscreteDataGenerator</code>: Generator for discrete covariate scenarios</li><li><code>ContinuousDataGenerator</code>: Generator for continuous covariate scenarios</li><li><code>read</code>: Load parameters from JSON file</li><li><code>save</code>: Persist parameters to JSON file</li></ul><p><strong>Notes</strong></p><ul><li>Dimensions: length(mA) = size(covA,1) and length(aA) = length(mA) must hold</li><li>Probabilities in pA/pB must sum to 1.0 for each dimension</li><li>r2 controls noise via σ²_error = (1/r² - 1) × Var(X&#39;a)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/otrecoding/OptimalTransportDataIntegration.jl/blob/e49f62c11e8b4356063a07fa7283a0c4f9906686/src/data_parameters.jl#L6">source</a></section></details></article><article><details class="docstring" open="true"><summary id="OptimalTransportDataIntegration.read-Tuple{AbstractString}"><a class="docstring-binding" href="#OptimalTransportDataIntegration.read-Tuple{AbstractString}"><code>OptimalTransportDataIntegration.read</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">read(jsonfile)
</code></pre><p>Load data generation scenario parameters from a JSON file.</p><p>Deserializes a JSON file containing all <code>DataParameters</code> fields and reconstructs a <code>DataParameters</code> instance. Useful for reproducible experiments across sessions and for tracking scenario configurations.</p><p><strong>Arguments</strong></p><ul><li><code>jsonfile::AbstractString</code>: Path to JSON file containing scenario parameters</li></ul><p><strong>Returns</strong></p><ul><li><code>DataParameters</code>: Reconstructed parameter object with all fields populated</li></ul><p><strong>File Format</strong></p><p>JSON structure with top-level keys matching <code>DataParameters</code> field names:</p><pre><code class="language-json hljs">{
  &quot;nA&quot;: 1000,
  &quot;nB&quot;: 1000,
  &quot;mA&quot;: [0.0, 0.0, 0.0],
  &quot;mB&quot;: [1.0, 1.0, 0.0],
  &quot;covA&quot;: [[1.0, 0.2, 0.2], [0.2, 1.0, 0.2], [0.2, 0.2, 1.0]],
  &quot;covB&quot;: [[1.0, 0.2, 0.2], [0.2, 1.0, 0.2], [0.2, 0.2, 1.0]],
  &quot;aA&quot;: [1.0, 1.0, 1.0],
  &quot;aB&quot;: [1.0, 1.0, 1.0],
  &quot;r2&quot;: 0.6,
  &quot;pA&quot;: [[0.5, 0.5], [0.333, 0.333, 0.333], [0.25, 0.25, 0.25, 0.25]],
  &quot;pB&quot;: [[0.8, 0.2], [0.333, 0.333, 0.333], [0.25, 0.25, 0.25, 0.25]]
}</code></pre><p><strong>Example</strong></p><pre><code class="language-julia hljs">params = read(&quot;scenario_1.json&quot;)
gen = DiscreteDataGenerator(params)
data = generate(gen)</code></pre><p><strong>See Also</strong></p><ul><li><code>save</code>: Persist parameters to JSON</li><li><code>DataParameters</code>: Parameter type</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/otrecoding/OptimalTransportDataIntegration.jl/blob/e49f62c11e8b4356063a07fa7283a0c4f9906686/src/data_parameters.jl#L79">source</a></section></details></article><article><details class="docstring" open="true"><summary id="OptimalTransportDataIntegration.save-Tuple{AbstractString, DataParameters}"><a class="docstring-binding" href="#OptimalTransportDataIntegration.save-Tuple{AbstractString, DataParameters}"><code>OptimalTransportDataIntegration.save</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">save(jsonfile, params)
</code></pre><p>Persist data generation scenario parameters to a JSON file.</p><p>Serializes all <code>DataParameters</code> fields to a JSON file for later retrieval. Essential for reproducible experiments: save parameters used in generation, then load them later to recreate identical scenarios.</p><p><strong>Arguments</strong></p><ul><li><code>jsonfile::AbstractString</code>: Path where JSON file will be written</li><li><code>params::DataParameters</code>: Parameter object to serialize</li></ul><p><strong>Returns</strong></p><ul><li>Nothing; writes JSON file as side effect</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">params = DataParameters(nA=500, nB=500, r2=0.8)
save(&quot;my_scenario.json&quot;, params)

# Later...
params_loaded = read(&quot;my_scenario.json&quot;)
@assert params == params_loaded  # Exact reproduction</code></pre><p><strong>See Also</strong></p><ul><li><code>read</code>: Load parameters from JSON</li><li><code>DataParameters</code>: Parameter type</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/otrecoding/OptimalTransportDataIntegration.jl/blob/e49f62c11e8b4356063a07fa7283a0c4f9906686/src/data_parameters.jl#L147">source</a></section></details></article><article><details class="docstring" open="true"><summary id="OptimalTransportDataIntegration.ContinuousDataGenerator"><a class="docstring-binding" href="#OptimalTransportDataIntegration.ContinuousDataGenerator"><code>OptimalTransportDataIntegration.ContinuousDataGenerator</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct ContinuousDataGenerator</code></pre><p>Factory for generating synthetic datasets with continuous covariates and categorical outcomes.</p><p>Generates two data sources (base A and B) with multivariate normal covariates (X) and  categorical outcomes (Y, Z) derived from linear combinations of X plus noise. The generator  pre-computes outcome quantiles and binning thresholds during construction for efficient  repeated generation via <code>generate()</code>.</p><p><strong>Fields</strong></p><ul><li><code>params::DataParameters</code>: Scenario parameters (means, covariances, effect sizes, outcome probabilities)</li><li><code>binsYA::Vector{Float64}</code>: Quantile thresholds for digitizing outcome Y in base A</li><li><code>binsZA::Vector{Float64}</code>: Quantile thresholds for digitizing outcome Z in base A</li><li><code>binsYB::Vector{Float64}</code>: Quantile thresholds for digitizing outcome Y in base B</li><li><code>binsZB::Vector{Float64}</code>: Quantile thresholds for digitizing outcome Z in base B</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">ContinuousDataGenerator(params; scenario=1, n=10000)</code></pre><p><strong>Arguments</strong></p><ul><li><code>params::DataParameters</code>: Data scenario parameters including:<ul><li><code>nA</code>, <code>nB</code>: Sample sizes for bases A and B</li><li><code>mA</code>, <code>mB</code>: Mean vectors for multivariate normal covariates</li><li><code>covA</code>, <code>covB</code>: Covariance matrices for covariates</li><li><code>aA</code>, <code>aB</code>: Effect size vectors (regression coefficients on X)</li><li><code>r2</code>: Coefficient of determination (controls noise level)</li><li><code>pA</code>, <code>pB</code>: Outcome category probabilities (unused for continuous generation)</li></ul></li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>scenario::Int</code>: Determines binning strategy; default: 1<ul><li><code>scenario=1</code>: Same binning thresholds for A and B (no covariate shift)</li><li><code>scenario≠1</code>: Separate binning thresholds per base (covariate shift)</li></ul></li><li><code>n::Int</code>: Unused parameter (kept for API compatibility); default: 10000</li></ul><p><strong>Generation Process (Constructor)</strong></p><ol><li>Sample covariates: XA ~ N(mA, covA) and XB ~ N(mB, covB)</li><li>Compute error variance from r² and effect sizes: σ²_error = (1/r² - 1) × ∑(aᵢ aⱼ Cov[i,j])</li><li>Generate latent outcomes: Y = X&#39;a + ε with ε ~ N(0, σ²_error)</li><li>Compute quantiles at [0.25, 0.5, 0.75] for Y and [1/3, 2/3] for Z</li><li>Create bins: <span>$[-∞, q₁, q₂, q₃, ∞]$</span> (4 categories) and <span>$[-∞, q₁, q₂, ∞]$</span> (3 categories)</li></ol><p><strong>See Also</strong></p><ul><li><code>DiscreteDataGenerator</code>: For categorical covariates</li><li><code>generate</code>: Call this method on generator to produce DataFrame</li></ul><p><strong>Notes</strong></p><ul><li>Covariates are continuous (multivariate normal)</li><li>Outcomes are always categorical (3-4 classes based on quantile binning)</li><li>R² parameter controls signal-to-noise ratio in linear model</li><li>Scenario parameter allows testing covariate shift and distribution mismatch assumptions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/otrecoding/OptimalTransportDataIntegration.jl/blob/e49f62c11e8b4356063a07fa7283a0c4f9906686/src/generate_continuous_data.jl#L3">source</a></section></details></article><article><details class="docstring" open="true"><summary id="OptimalTransportDataIntegration.generate-Tuple{ContinuousDataGenerator}"><a class="docstring-binding" href="#OptimalTransportDataIntegration.generate-Tuple{ContinuousDataGenerator}"><code>OptimalTransportDataIntegration.generate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">generate(generator; eps)
</code></pre><p>Generate a synthetic dataset with continuous covariates and categorical outcomes.</p><p>Samples new covariates from the multivariate normal distributions specified in generator, computes latent outcomes via linear model, then discretizes into categorical bins pre-computed during generator construction.</p><p><strong>Arguments</strong></p><ul><li><code>generator::ContinuousDataGenerator</code>: Pre-configured generator with binning thresholds</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>eps::Float64</code>: Offset added to outcome Z binning thresholds (for covariate shift sensitivity); default: 0.0</li></ul><p><strong>Returns</strong></p><ul><li><code>DataFrame</code>: Dataset with columns:<ul><li><code>X1, X2, ...</code>: Continuous covariates (dimension matches <code>params.mA</code> length)</li><li><code>Y</code>: Categorical outcome (1:4) indicating base B&#39;s observed outcome</li><li><code>Z</code>: Categorical outcome (1:3) indicating base A&#39;s observed outcome</li><li><code>database</code>: Integer (1 for base A, 2 for base B) indicating data source</li><li>Total rows: <code>params.nA + params.nB</code></li></ul></li></ul><p><strong>Algorithm</strong></p><ol><li>Sample covariates: XA ~ N(mA, covA) and XB ~ N(mB, covB)</li><li>Compute latent outcomes: Y1 = XA&#39;·aA + ε<em>A and Y2 = XB&#39;·aB + ε</em>B</li><li>Digitize into categories using pre-computed bins:<ul><li>YA = digitize(Y1, binsYA), ZA = digitize(Y1, binsZA)</li><li>YB = digitize(Y2, binsYB + eps), ZB = digitize(Y2, binsZB + eps)</li></ul></li><li>Assemble DataFrame with database indicator</li><li>Log category distributions (info level)</li></ol><p><strong>Details</strong></p><ul><li><strong>Data split</strong>: Base A (database=1) has outcomes Z, Base B (database=2) has outcomes Y</li><li><strong>Missing outcomes</strong>: Implicit in database indicator (no NAs in columns)</li><li><strong>Outcome relationship</strong>: Z and Y in same base are derived from same latent variable</li><li><strong>eps parameter</strong>: Small perturbation useful for testing robustness to binning threshold changes</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">params = DataParameters(nA=500, nB=500, r2=0.6)
gen = ContinuousDataGenerator(params)
data = generate(gen)  # 1000 rows × 5 columns</code></pre><p><strong>See Also</strong></p><ul><li><code>ContinuousDataGenerator</code>: Constructor with binning logic</li><li><code>DiscreteDataGenerator</code> / <code>generate</code>: Discrete covariates alternative</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/otrecoding/OptimalTransportDataIntegration.jl/blob/e49f62c11e8b4356063a07fa7283a0c4f9906686/src/generate_continuous_data.jl#L134">source</a></section></details></article><article><details class="docstring" open="true"><summary id="OptimalTransportDataIntegration.DiscreteDataGenerator"><a class="docstring-binding" href="#OptimalTransportDataIntegration.DiscreteDataGenerator"><code>OptimalTransportDataIntegration.DiscreteDataGenerator</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct DiscreteDataGenerator</code></pre><p>Factory for generating synthetic datasets with discrete (categorical) covariates and categorical outcomes.</p><p>Generates two data sources (base A and B) with categorical covariates (X) sampled from  multinomial distributions and categorical outcomes (Y, Z) derived from linear combinations of  X indicators plus noise. The generator pre-computes outcome quantiles and binning thresholds  during construction for efficient repeated generation via <code>generate()</code>.</p><p><strong>Fields</strong></p><ul><li><code>params::DataParameters</code>: Scenario parameters (outcome probabilities, effect sizes, r²)</li><li><code>covA::Matrix{Float64}</code>: Empirical covariance matrix of covariates in base A</li><li><code>covB::Matrix{Float64}</code>: Empirical covariance matrix of covariates in base B</li><li><code>binsYA::Vector{Float64}</code>: Quantile thresholds for digitizing outcome Y in base A</li><li><code>binsZA::Vector{Float64}</code>: Quantile thresholds for digitizing outcome Z in base A</li><li><code>binsYB::Vector{Float64}</code>: Quantile thresholds for digitizing outcome Y in base B</li><li><code>binsZB::Vector{Float64}</code>: Quantile thresholds for digitizing outcome Z in base B</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">DiscreteDataGenerator(params; scenario=1, n=10000)</code></pre><p><strong>Arguments</strong></p><ul><li><code>params::DataParameters</code>: Data scenario parameters including:<ul><li><code>nA</code>, <code>nB</code>: Sample sizes for bases A and B</li><li><code>pA</code>, <code>pB</code>: Outcome category probabilities as vectors of vectors</li><li><code>pA[1]</code>: Probabilities for 1st covariate categories</li><li><code>pA[2]</code>: Probabilities for 2nd covariate categories, etc.</li><li><code>aA</code>, <code>aB</code>: Effect size vectors (regression coefficients for covariate indicators)</li><li><code>r2</code>: Coefficient of determination (controls noise level)</li></ul></li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>scenario::Int</code>: Determines binning strategy; default: 1<ul><li><code>scenario=1</code>: Same binning thresholds for A and B (no covariate shift)</li><li><code>scenario≠1</code>: Separate binning thresholds per base (covariate shift)</li></ul></li><li><code>n::Int</code>: Unused parameter (kept for API compatibility); default: 10000</li></ul><p><strong>Generation Process (Constructor)</strong></p><ol><li>Sample categorical covariates: XA[i,j] ~ Categorical(pA[j]) for each dimension</li><li>Compute empirical covariances of sampled covariates</li><li>Compute error variance from r² and effect sizes: σ²_error = (1/r² - 1) × ∑(aᵢ aⱼ Cov[i,j])</li><li>Generate latent outcomes: Y = X&#39;a + ε with ε ~ N(0, σ²_error) (when σ² &gt; 0)</li><li>Compute quantiles at [0.25, 0.5, 0.75] for Y and [1/3, 2/3] for Z</li><li>Create bins: <span>$[-∞, q₁, q₂, q₃, ∞]$</span> (4 categories) and <span>$[-∞, q₁, q₂, ∞]$</span> (3 categories)</li></ol><p><strong>See Also</strong></p><ul><li><code>ContinuousDataGenerator</code>: For continuous (multivariate normal) covariates</li><li><code>generate</code>: Call this method on generator to produce DataFrame</li></ul><p><strong>Notes</strong></p><ul><li>Covariates are categorical (sampled from multinomial distributions)</li><li>Outcomes are always categorical (3-4 classes based on quantile binning)</li><li>R² parameter controls signal-to-noise ratio in linear model</li><li>Scenario parameter allows testing covariate shift and distribution mismatch assumptions</li><li>Covariance matrices computed from sampled data may vary between generator instances</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/otrecoding/OptimalTransportDataIntegration.jl/blob/e49f62c11e8b4356063a07fa7283a0c4f9906686/src/generate_discrete_data.jl#L16">source</a></section></details></article><article><details class="docstring" open="true"><summary id="OptimalTransportDataIntegration.generate-Tuple{DiscreteDataGenerator}"><a class="docstring-binding" href="#OptimalTransportDataIntegration.generate-Tuple{DiscreteDataGenerator}"><code>OptimalTransportDataIntegration.generate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">generate(generator; eps)
</code></pre><p>Generate a synthetic dataset with discrete (categorical) covariates and categorical outcomes.</p><p>Samples new categorical covariates from multinomial distributions specified in generator, computes latent outcomes via linear model on covariate indicators, then discretizes into  categorical bins pre-computed during generator construction.</p><p><strong>Arguments</strong></p><ul><li><code>generator::DiscreteDataGenerator</code>: Pre-configured generator with binning thresholds and covariance estimates</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>eps::Float64</code>: Offset added to outcome Z binning thresholds (for covariate shift sensitivity); default: 0.0</li></ul><p><strong>Returns</strong></p><ul><li><code>DataFrame</code>: Dataset with columns:<ul><li><code>X1, X2, ...</code>: Categorical covariates (dimension matches <code>length(params.pA)</code>)</li><li><code>Y</code>: Categorical outcome (1:4) indicating base B&#39;s observed outcome</li><li><code>Z</code>: Categorical outcome (1:3) indicating base A&#39;s observed outcome</li><li><code>database</code>: Integer (1 for base A, 2 for base B) indicating data source</li><li>Total rows: <code>params.nA + params.nB</code></li></ul></li></ul><p><strong>Algorithm</strong></p><ol><li>Sample categorical covariates: XA[i,j] ~ Categorical(pA[j]) for each base independently</li><li>Compute latent outcomes: Y1 = XA&#39;·aA + ε<em>A and Y2 = XB&#39;·aB + ε</em>B</li><li>Digitize into categories using pre-computed bins:<ul><li>YA = digitize(Y1, binsYA), ZA = digitize(Y1, binsZA)</li><li>YB = digitize(Y2, binsYB + eps), ZB = digitize(Y2, binsZB + eps)</li></ul></li><li>Assemble DataFrame with database indicator</li><li>Log category distributions (info level)</li></ol><p><strong>Details</strong></p><ul><li><strong>Data split</strong>: Base A (database=1) has outcomes Z, Base B (database=2) has outcomes Y</li><li><strong>Missing outcomes</strong>: Implicit in database indicator (no NAs in columns)</li><li><strong>Outcome relationship</strong>: Z and Y in same base are derived from same latent variable</li><li><strong>eps parameter</strong>: Small perturbation useful for testing robustness to binning threshold changes</li><li><strong>Covariate sampling</strong>: Independent samples each call, so distributions may vary slightly from params</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">params = DataParameters(nA=500, nB=500, r2=0.6)
gen = DiscreteDataGenerator(params, scenario=1)
data = generate(gen)  # 1000 rows × 5 columns (3 covariates + Y + Z + database)</code></pre><p><strong>See Also</strong></p><ul><li><code>DiscreteDataGenerator</code>: Constructor with binning logic</li><li><code>ContinuousDataGenerator</code> / <code>generate</code>: Continuous covariates alternative</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/otrecoding/OptimalTransportDataIntegration.jl/blob/e49f62c11e8b4356063a07fa7283a0c4f9906686/src/generate_discrete_data.jl#L154">source</a></section></details></article><h2 id="Helper-functions"><a class="docs-heading-anchor" href="#Helper-functions">Helper functions</a><a id="Helper-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Helper-functions" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="OptimalTransportDataIntegration.accuracy"><a class="docstring-binding" href="#OptimalTransportDataIntegration.accuracy"><code>OptimalTransportDataIntegration.accuracy</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">accuracy(ypred, ytrue)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/otrecoding/OptimalTransportDataIntegration.jl/blob/e49f62c11e8b4356063a07fa7283a0c4f9906686/src/OptimalTransportDataIntegration.jl#L46">source</a></section><section><div><pre><code class="language-julia hljs">accuracy(data, yb_pred, za_pred)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/otrecoding/OptimalTransportDataIntegration.jl/blob/e49f62c11e8b4356063a07fa7283a0c4f9906686/src/OptimalTransportDataIntegration.jl#L51">source</a></section><section><div><pre><code class="language-julia hljs">accuracy(sol)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/otrecoding/OptimalTransportDataIntegration.jl/blob/e49f62c11e8b4356063a07fa7283a0c4f9906686/src/OptimalTransportDataIntegration.jl#L74">source</a></section></details></article><article><details class="docstring" open="true"><summary id="OptimalTransportDataIntegration.confusion_matrix"><a class="docstring-binding" href="#OptimalTransportDataIntegration.confusion_matrix"><code>OptimalTransportDataIntegration.confusion_matrix</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">confusion_matrix(y_true, y_pred; classes)
</code></pre><p>made by claude.ai</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/otrecoding/OptimalTransportDataIntegration.jl/blob/e49f62c11e8b4356063a07fa7283a0c4f9906686/src/OptimalTransportDataIntegration.jl#L87">source</a></section></details></article><article><details class="docstring" open="true"><summary id="OptimalTransportDataIntegration.compute_pred_error!"><a class="docstring-binding" href="#OptimalTransportDataIntegration.compute_pred_error!"><code>OptimalTransportDataIntegration.compute_pred_error!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">compute_pred_error!(sol, inst)
compute_pred_error!(sol, inst, proba_disp)
compute_pred_error!(sol, inst, proba_disp, mis_disp)
compute_pred_error!(
    sol,
    inst,
    proba_disp,
    mis_disp,
    full_disp
)
</code></pre><p>Compute prediction errors in a solution</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/otrecoding/OptimalTransportDataIntegration.jl/blob/e49f62c11e8b4356063a07fa7283a0c4f9906686/src/pred_error.jl#L3">source</a></section></details></article><ul><li><a href="#OptimalTransportDataIntegration.ContinuousDataGenerator"><code>OptimalTransportDataIntegration.ContinuousDataGenerator</code></a></li><li><a href="#OptimalTransportDataIntegration.DataParameters"><code>OptimalTransportDataIntegration.DataParameters</code></a></li><li><a href="#OptimalTransportDataIntegration.DiscreteDataGenerator"><code>OptimalTransportDataIntegration.DiscreteDataGenerator</code></a></li><li><a href="joint_ot_within_base/#OptimalTransportDataIntegration.Instance"><code>OptimalTransportDataIntegration.Instance</code></a></li><li><a href="joint_ot_within_base/#OptimalTransportDataIntegration.Solution"><code>OptimalTransportDataIntegration.Solution</code></a></li><li><a href="#OptimalTransportDataIntegration.accuracy"><code>OptimalTransportDataIntegration.accuracy</code></a></li><li><a href="joint_ot_within_base/#OptimalTransportDataIntegration.average_distance_to_closest-Tuple{Instance, Float64}"><code>OptimalTransportDataIntegration.average_distance_to_closest</code></a></li><li><a href="#OptimalTransportDataIntegration.compute_pred_error!"><code>OptimalTransportDataIntegration.compute_pred_error!</code></a></li><li><a href="#OptimalTransportDataIntegration.confusion_matrix"><code>OptimalTransportDataIntegration.confusion_matrix</code></a></li><li><a href="#OptimalTransportDataIntegration.generate-Tuple{DiscreteDataGenerator}"><code>OptimalTransportDataIntegration.generate</code></a></li><li><a href="#OptimalTransportDataIntegration.generate-Tuple{ContinuousDataGenerator}"><code>OptimalTransportDataIntegration.generate</code></a></li><li><a href="joint_ot_between_bases/#OptimalTransportDataIntegration.joint_ot_between_bases_category-NTuple{4, Any}"><code>OptimalTransportDataIntegration.joint_ot_between_bases_category</code></a></li><li><a href="joint_ot_between_bases/#OptimalTransportDataIntegration.joint_ot_between_bases_da_covariables-Tuple{Any}"><code>OptimalTransportDataIntegration.joint_ot_between_bases_da_covariables</code></a></li><li><a href="joint_ot_between_bases/#OptimalTransportDataIntegration.joint_ot_between_bases_da_outcomes-Tuple{Any}"><code>OptimalTransportDataIntegration.joint_ot_between_bases_da_outcomes</code></a></li><li><a href="joint_ot_between_bases/#OptimalTransportDataIntegration.joint_ot_between_bases_da_outcomes_with_predictors-Tuple{Any}"><code>OptimalTransportDataIntegration.joint_ot_between_bases_da_outcomes_with_predictors</code></a></li><li><a href="joint_ot_between_bases/#OptimalTransportDataIntegration.joint_ot_between_bases_discrete-NTuple{4, Any}"><code>OptimalTransportDataIntegration.joint_ot_between_bases_discrete</code></a></li><li><a href="joint_ot_between_bases/#OptimalTransportDataIntegration.joint_ot_between_bases_jdot-Tuple{Any}"><code>OptimalTransportDataIntegration.joint_ot_between_bases_jdot</code></a></li><li><a href="joint_ot_between_bases/#OptimalTransportDataIntegration.joint_ot_between_bases_with_predictors-Tuple{Any}"><code>OptimalTransportDataIntegration.joint_ot_between_bases_with_predictors</code></a></li><li><a href="joint_ot_between_bases/#OptimalTransportDataIntegration.joint_ot_between_bases_without_outcomes-Tuple{Any}"><code>OptimalTransportDataIntegration.joint_ot_between_bases_without_outcomes</code></a></li><li><a href="joint_ot_within_base/#OptimalTransportDataIntegration.joint_ot_within_base_continuous-Tuple{Any}"><code>OptimalTransportDataIntegration.joint_ot_within_base_continuous</code></a></li><li><a href="learning/#OptimalTransportDataIntegration.learning_with_continuous_data-Tuple{Any}"><code>OptimalTransportDataIntegration.learning_with_continuous_data</code></a></li><li><a href="learning/#OptimalTransportDataIntegration.onehot-Tuple{AbstractMatrix}"><code>OptimalTransportDataIntegration.onehot</code></a></li><li><a href="joint_ot_within_base/#OptimalTransportDataIntegration.ot_joint-Tuple{Instance, Float64, Float64, Float64}"><code>OptimalTransportDataIntegration.ot_joint</code></a></li><li><a href="#OptimalTransportDataIntegration.read-Tuple{AbstractString}"><code>OptimalTransportDataIntegration.read</code></a></li><li><a href="#OptimalTransportDataIntegration.save-Tuple{AbstractString, DataParameters}"><code>OptimalTransportDataIntegration.save</code></a></li><li><a href="learning/#OptimalTransportDataIntegration.simple_learning-Tuple{Any}"><code>OptimalTransportDataIntegration.simple_learning</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="joint_ot_within_base/">Transport within a data source »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Thursday 8 January 2026 10:57">Thursday 8 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
