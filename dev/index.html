<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Quickstart · OptimalTransportDataIntegration</title><meta name="title" content="Quickstart · OptimalTransportDataIntegration"/><meta property="og:title" content="Quickstart · OptimalTransportDataIntegration"/><meta property="twitter:title" content="Quickstart · OptimalTransportDataIntegration"/><meta name="description" content="Documentation for OptimalTransportDataIntegration."/><meta property="og:description" content="Documentation for OptimalTransportDataIntegration."/><meta property="twitter:description" content="Documentation for OptimalTransportDataIntegration."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>OptimalTransportDataIntegration</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Quickstart</a><ul class="internal"><li><a class="tocitem" href="#Simulation-data-generation"><span>Simulation data generation</span></a></li><li><a class="tocitem" href="#Recoding-methods"><span>Recoding methods</span></a></li><li><a class="tocitem" href="#Helper-functions"><span>Helper functions</span></a></li></ul></li><li><a class="tocitem" href="joint_ot_within_base/">Transport within a data source</a></li><li><a class="tocitem" href="joint_ot_between_bases/">Transport between data sources</a></li><li><a class="tocitem" href="learning/">Machine Learning</a></li><li><a class="tocitem" href="simulations/">Numerical experiments</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Quickstart</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Quickstart</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/otrecoding/OptimalTransportDataIntegration.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/otrecoding/OptimalTransportDataIntegration.jl/blob/main/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="OptimalTransportDataIntegration.jl"><a class="docs-heading-anchor" href="#OptimalTransportDataIntegration.jl">OptimalTransportDataIntegration.jl</a><a id="OptimalTransportDataIntegration.jl-1"></a><a class="docs-heading-anchor-permalink" href="#OptimalTransportDataIntegration.jl" title="Permalink"></a></h1><h2 id="Simulation-data-generation"><a class="docs-heading-anchor" href="#Simulation-data-generation">Simulation data generation</a><a id="Simulation-data-generation-1"></a><a class="docs-heading-anchor-permalink" href="#Simulation-data-generation" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="OptimalTransportDataIntegration.DataParameters"><a class="docstring-binding" href="#OptimalTransportDataIntegration.DataParameters"><code>OptimalTransportDataIntegration.DataParameters</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct DataParameters</code></pre><p>Scenario parameters for synthetic data generation.</p><p>Specifies all hyperparameters controlling data generation for both discrete and continuous covariate settings. Includes sample sizes, covariate distributions, effect sizes, noise levels, and outcome category probabilities. Can be persisted to/from JSON for reproducible experiments.</p><p><strong>Fields</strong></p><ul><li><code>nA::Int</code>: Sample size for base A; default: 1000</li><li><code>nB::Int</code>: Sample size for base B; default: 1000</li><li><code>mA::Vector{Float64}</code>: Mean vector for base A covariates (MVN); default: [0.0, 0.0, 0.0]</li><li><code>mB::Vector{Float64}</code>: Mean vector for base B covariates (MVN); default: [1.0, 1.0, 0.0]</li><li><code>covA::Matrix{Float64}</code>: Covariance matrix for base A covariates; default: 3×3 with diag=1, off-diag=0.2</li><li><code>covB::Matrix{Float64}</code>: Covariance matrix for base B covariates; default: 3×3 with diag=1, off-diag=0.2</li><li><code>aA::Vector{Float64}</code>: Effect sizes (regression coefficients) for base A outcomes; default: [1.0, 1.0, 1.0]</li><li><code>aB::Vector{Float64}</code>: Effect sizes (regression coefficients) for base B outcomes; default: [1.0, 1.0, 1.0]</li><li><code>r2::Float64</code>: Coefficient of determination (signal-to-noise ratio); default: 0.6 (higher = stronger signal)</li><li><code>pA::Vector{Vector{Float64}}</code>: Category probabilities for base A categorical covariates (one vector per dimension)<ul><li>default: [[0.5, 0.5], [1/3, 1/3, 1/3], [0.25, 0.25, 0.25, 0.25]]</li><li>For discrete generator: multinomial probabilities</li><li>For continuous generator: unused</li></ul></li><li><code>pB::Vector{Vector{Float64}}</code>: Category probabilities for base B categorical covariates (one vector per dimension)<ul><li>default: [[0.8, 0.2], [1/3, 1/3, 1/3], [0.25, 0.25, 0.25, 0.25]]</li><li>For discrete generator: multinomial probabilities</li><li>For continuous generator: unused</li></ul></li></ul><p><strong>Usage</strong></p><p>Create with defaults:</p><pre><code class="language-julia hljs">params = DataParameters()</code></pre><p>Customize selected fields:</p><pre><code class="language-julia hljs">params = DataParameters(nA=500, nB=500, r2=0.8, mB=[2.0, 2.0, 0.0])</code></pre><p><strong>Key Concepts</strong></p><ul><li><strong>Covariate Shift</strong>: Controlled by different mA/mB (continuous) or pA/pB (discrete)</li><li><strong>Sample Imbalance</strong>: Controlled by different nA/nB</li><li><strong>Signal Strength</strong>: Controlled by r2 (0 = pure noise, 1 = perfect signal)</li><li><strong>Effect Sizes</strong>: aA/aB control how strongly outcomes depend on covariates</li><li><strong>Bases Design</strong>: Base A has outcome Z, Base B has outcome Y; X covariates overlap</li></ul><p><strong>See Also</strong></p><ul><li><code>DiscreteDataGenerator</code>: Generator for discrete covariate scenarios</li><li><code>ContinuousDataGenerator</code>: Generator for continuous covariate scenarios</li><li><code>read</code>: Load parameters from JSON file</li><li><code>save</code>: Persist parameters to JSON file</li></ul><p><strong>Notes</strong></p><ul><li>Dimensions: length(mA) = size(covA,1) and length(aA) = length(mA) must hold</li><li>Probabilities in pA/pB must sum to 1.0 for each dimension</li><li>r2 controls noise via σ²_error = (1/r² - 1) × Var(X&#39;a)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/otrecoding/OptimalTransportDataIntegration.jl/blob/972b019290e46df9e35cbe73eb02472dab094ed6/src/data_parameters.jl#L6">source</a></section></details></article><article><details class="docstring" open="true"><summary id="OptimalTransportDataIntegration.read-Tuple{AbstractString}"><a class="docstring-binding" href="#OptimalTransportDataIntegration.read-Tuple{AbstractString}"><code>OptimalTransportDataIntegration.read</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">read(jsonfile)
</code></pre><p>Load data generation scenario parameters from a JSON file.</p><p>Deserializes a JSON file containing all <code>DataParameters</code> fields and reconstructs a <code>DataParameters</code> instance. Useful for reproducible experiments across sessions and for tracking scenario configurations.</p><p><strong>Arguments</strong></p><ul><li><code>jsonfile::AbstractString</code>: Path to JSON file containing scenario parameters</li></ul><p><strong>Returns</strong></p><ul><li><code>DataParameters</code>: Reconstructed parameter object with all fields populated</li></ul><p><strong>File Format</strong></p><p>JSON structure with top-level keys matching <code>DataParameters</code> field names:</p><pre><code class="language-json hljs">{
  &quot;nA&quot;: 1000,
  &quot;nB&quot;: 1000,
  &quot;mA&quot;: [0.0, 0.0, 0.0],
  &quot;mB&quot;: [1.0, 1.0, 0.0],
  &quot;covA&quot;: [[1.0, 0.2, 0.2], [0.2, 1.0, 0.2], [0.2, 0.2, 1.0]],
  &quot;covB&quot;: [[1.0, 0.2, 0.2], [0.2, 1.0, 0.2], [0.2, 0.2, 1.0]],
  &quot;aA&quot;: [1.0, 1.0, 1.0],
  &quot;aB&quot;: [1.0, 1.0, 1.0],
  &quot;r2&quot;: 0.6,
  &quot;pA&quot;: [[0.5, 0.5], [0.333, 0.333, 0.333], [0.25, 0.25, 0.25, 0.25]],
  &quot;pB&quot;: [[0.8, 0.2], [0.333, 0.333, 0.333], [0.25, 0.25, 0.25, 0.25]]
}</code></pre><p><strong>Example</strong></p><pre><code class="language-julia hljs">params = read(&quot;scenario_1.json&quot;)
gen = DiscreteDataGenerator(params)
data = generate(gen)</code></pre><p><strong>See Also</strong></p><ul><li><code>save</code>: Persist parameters to JSON</li><li><code>DataParameters</code>: Parameter type</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/otrecoding/OptimalTransportDataIntegration.jl/blob/972b019290e46df9e35cbe73eb02472dab094ed6/src/data_parameters.jl#L79">source</a></section></details></article><article><details class="docstring" open="true"><summary id="OptimalTransportDataIntegration.save-Tuple{AbstractString, DataParameters}"><a class="docstring-binding" href="#OptimalTransportDataIntegration.save-Tuple{AbstractString, DataParameters}"><code>OptimalTransportDataIntegration.save</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">save(jsonfile, params)
</code></pre><p>Persist data generation scenario parameters to a JSON file.</p><p>Serializes all <code>DataParameters</code> fields to a JSON file for later retrieval. Essential for reproducible experiments: save parameters used in generation, then load them later to recreate identical scenarios.</p><p><strong>Arguments</strong></p><ul><li><code>jsonfile::AbstractString</code>: Path where JSON file will be written</li><li><code>params::DataParameters</code>: Parameter object to serialize</li></ul><p><strong>Returns</strong></p><ul><li>Nothing; writes JSON file as side effect</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">params = DataParameters(nA=500, nB=500, r2=0.8)
save(&quot;my_scenario.json&quot;, params)

# Later...
params_loaded = read(&quot;my_scenario.json&quot;)
@assert params == params_loaded  # Exact reproduction</code></pre><p><strong>See Also</strong></p><ul><li><code>read</code>: Load parameters from JSON</li><li><code>DataParameters</code>: Parameter type</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/otrecoding/OptimalTransportDataIntegration.jl/blob/972b019290e46df9e35cbe73eb02472dab094ed6/src/data_parameters.jl#L147">source</a></section></details></article><article><details class="docstring" open="true"><summary id="OptimalTransportDataIntegration.ContinuousDataGenerator"><a class="docstring-binding" href="#OptimalTransportDataIntegration.ContinuousDataGenerator"><code>OptimalTransportDataIntegration.ContinuousDataGenerator</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct ContinuousDataGenerator</code></pre><p>Factory for generating synthetic datasets with continuous covariates and categorical outcomes.</p><p>Generates two data sources (base A and B) with multivariate normal covariates (X) and  categorical outcomes (Y, Z) derived from linear combinations of X plus noise. The generator  pre-computes outcome quantiles and binning thresholds during construction for efficient  repeated generation via <code>generate()</code>.</p><p><strong>Fields</strong></p><ul><li><code>params::DataParameters</code>: Scenario parameters (means, covariances, effect sizes, outcome probabilities)</li><li><code>binsYA::Vector{Float64}</code>: Quantile thresholds for digitizing outcome Y in base A</li><li><code>binsZA::Vector{Float64}</code>: Quantile thresholds for digitizing outcome Z in base A</li><li><code>binsYB::Vector{Float64}</code>: Quantile thresholds for digitizing outcome Y in base B</li><li><code>binsZB::Vector{Float64}</code>: Quantile thresholds for digitizing outcome Z in base B</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">ContinuousDataGenerator(params; scenario=1, n=10000)</code></pre><p><strong>Arguments</strong></p><ul><li><code>params::DataParameters</code>: Data scenario parameters including:<ul><li><code>nA</code>, <code>nB</code>: Sample sizes for bases A and B</li><li><code>mA</code>, <code>mB</code>: Mean vectors for multivariate normal covariates</li><li><code>covA</code>, <code>covB</code>: Covariance matrices for covariates</li><li><code>aA</code>, <code>aB</code>: Effect size vectors (regression coefficients on X)</li><li><code>r2</code>: Coefficient of determination (controls noise level)</li><li><code>pA</code>, <code>pB</code>: Outcome category probabilities (unused for continuous generation)</li></ul></li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>scenario::Int</code>: Determines binning strategy; default: 1<ul><li><code>scenario=1</code>: Same binning thresholds for A and B (no covariate shift)</li><li><code>scenario≠1</code>: Separate binning thresholds per base (covariate shift)</li></ul></li><li><code>n::Int</code>: Unused parameter (kept for API compatibility); default: 10000</li></ul><p><strong>Generation Process (Constructor)</strong></p><ol><li>Sample covariates: XA ~ N(mA, covA) and XB ~ N(mB, covB)</li><li>Compute error variance from r² and effect sizes: σ²_error = (1/r² - 1) × ∑(aᵢ aⱼ Cov[i,j])</li><li>Generate latent outcomes: Y = X&#39;a + ε with ε ~ N(0, σ²_error)</li><li>Compute quantiles at [0.25, 0.5, 0.75] for Y and [1/3, 2/3] for Z</li><li>Create bins: <span>$[-∞, q₁, q₂, q₃, ∞]$</span> (4 categories) and <span>$[-∞, q₁, q₂, ∞]$</span> (3 categories)</li></ol><p><strong>See Also</strong></p><ul><li><code>DiscreteDataGenerator</code>: For categorical covariates</li><li><code>generate</code>: Call this method on generator to produce DataFrame</li></ul><p><strong>Notes</strong></p><ul><li>Covariates are continuous (multivariate normal)</li><li>Outcomes are always categorical (3-4 classes based on quantile binning)</li><li>R² parameter controls signal-to-noise ratio in linear model</li><li>Scenario parameter allows testing covariate shift and distribution mismatch assumptions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/otrecoding/OptimalTransportDataIntegration.jl/blob/972b019290e46df9e35cbe73eb02472dab094ed6/src/generate_continuous_data.jl#L3">source</a></section></details></article><article><details class="docstring" open="true"><summary id="OptimalTransportDataIntegration.generate-Tuple{ContinuousDataGenerator}"><a class="docstring-binding" href="#OptimalTransportDataIntegration.generate-Tuple{ContinuousDataGenerator}"><code>OptimalTransportDataIntegration.generate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">generate(generator; eps)
</code></pre><p>Generate a synthetic dataset with continuous covariates and categorical outcomes.</p><p>Samples new covariates from the multivariate normal distributions specified in generator, computes latent outcomes via linear model, then discretizes into categorical bins pre-computed during generator construction.</p><p><strong>Arguments</strong></p><ul><li><code>generator::ContinuousDataGenerator</code>: Pre-configured generator with binning thresholds</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>eps::Float64</code>: Offset added to outcome Z binning thresholds (for covariate shift sensitivity); default: 0.0</li></ul><p><strong>Returns</strong></p><ul><li><code>DataFrame</code>: Dataset with columns:<ul><li><code>X1, X2, ...</code>: Continuous covariates (dimension matches <code>params.mA</code> length)</li><li><code>Y</code>: Categorical outcome (1:4) indicating base B&#39;s observed outcome</li><li><code>Z</code>: Categorical outcome (1:3) indicating base A&#39;s observed outcome</li><li><code>database</code>: Integer (1 for base A, 2 for base B) indicating data source</li><li>Total rows: <code>params.nA + params.nB</code></li></ul></li></ul><p><strong>Algorithm</strong></p><ol><li>Sample covariates: XA ~ N(mA, covA) and XB ~ N(mB, covB)</li><li>Compute latent outcomes: Y1 = XA&#39;·aA + ε<em>A and Y2 = XB&#39;·aB + ε</em>B</li><li>Digitize into categories using pre-computed bins:<ul><li>YA = digitize(Y1, binsYA), ZA = digitize(Y1, binsZA)</li><li>YB = digitize(Y2, binsYB + eps), ZB = digitize(Y2, binsZB + eps)</li></ul></li><li>Assemble DataFrame with database indicator</li><li>Log category distributions (info level)</li></ol><p><strong>Details</strong></p><ul><li><strong>Data split</strong>: Base A (database=1) has outcomes Z, Base B (database=2) has outcomes Y</li><li><strong>Missing outcomes</strong>: Implicit in database indicator (no NAs in columns)</li><li><strong>Outcome relationship</strong>: Z and Y in same base are derived from same latent variable</li><li><strong>eps parameter</strong>: Small perturbation useful for testing robustness to binning threshold changes</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">params = DataParameters(nA=500, nB=500, r2=0.6)
gen = ContinuousDataGenerator(params)
data = generate(gen)  # 1000 rows × 5 columns</code></pre><p><strong>See Also</strong></p><ul><li><code>ContinuousDataGenerator</code>: Constructor with binning logic</li><li><code>DiscreteDataGenerator</code> / <code>generate</code>: Discrete covariates alternative</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/otrecoding/OptimalTransportDataIntegration.jl/blob/972b019290e46df9e35cbe73eb02472dab094ed6/src/generate_continuous_data.jl#L134">source</a></section></details></article><article><details class="docstring" open="true"><summary id="OptimalTransportDataIntegration.DiscreteDataGenerator"><a class="docstring-binding" href="#OptimalTransportDataIntegration.DiscreteDataGenerator"><code>OptimalTransportDataIntegration.DiscreteDataGenerator</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">struct DiscreteDataGenerator</code></pre><p>Factory for generating synthetic datasets with discrete (categorical) covariates and categorical outcomes.</p><p>Generates two data sources (base A and B) with categorical covariates (X) sampled from  multinomial distributions and categorical outcomes (Y, Z) derived from linear combinations of  X indicators plus noise. The generator pre-computes outcome quantiles and binning thresholds  during construction for efficient repeated generation via <code>generate()</code>.</p><p><strong>Fields</strong></p><ul><li><code>params::DataParameters</code>: Scenario parameters (outcome probabilities, effect sizes, r²)</li><li><code>covA::Matrix{Float64}</code>: Empirical covariance matrix of covariates in base A</li><li><code>covB::Matrix{Float64}</code>: Empirical covariance matrix of covariates in base B</li><li><code>binsYA::Vector{Float64}</code>: Quantile thresholds for digitizing outcome Y in base A</li><li><code>binsZA::Vector{Float64}</code>: Quantile thresholds for digitizing outcome Z in base A</li><li><code>binsYB::Vector{Float64}</code>: Quantile thresholds for digitizing outcome Y in base B</li><li><code>binsZB::Vector{Float64}</code>: Quantile thresholds for digitizing outcome Z in base B</li></ul><p><strong>Constructor</strong></p><pre><code class="language-julia hljs">DiscreteDataGenerator(params; scenario=1, n=10000)</code></pre><p><strong>Arguments</strong></p><ul><li><code>params::DataParameters</code>: Data scenario parameters including:<ul><li><code>nA</code>, <code>nB</code>: Sample sizes for bases A and B</li><li><code>pA</code>, <code>pB</code>: Outcome category probabilities as vectors of vectors</li><li><code>pA[1]</code>: Probabilities for 1st covariate categories</li><li><code>pA[2]</code>: Probabilities for 2nd covariate categories, etc.</li><li><code>aA</code>, <code>aB</code>: Effect size vectors (regression coefficients for covariate indicators)</li><li><code>r2</code>: Coefficient of determination (controls noise level)</li></ul></li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>scenario::Int</code>: Determines binning strategy; default: 1<ul><li><code>scenario=1</code>: Same binning thresholds for A and B (no covariate shift)</li><li><code>scenario≠1</code>: Separate binning thresholds per base (covariate shift)</li></ul></li><li><code>n::Int</code>: Unused parameter (kept for API compatibility); default: 10000</li></ul><p><strong>Generation Process (Constructor)</strong></p><ol><li>Sample categorical covariates: XA[i,j] ~ Categorical(pA[j]) for each dimension</li><li>Compute empirical covariances of sampled covariates</li><li>Compute error variance from r² and effect sizes: σ²_error = (1/r² - 1) × ∑(aᵢ aⱼ Cov[i,j])</li><li>Generate latent outcomes: Y = X&#39;a + ε with ε ~ N(0, σ²_error) (when σ² &gt; 0)</li><li>Compute quantiles at [0.25, 0.5, 0.75] for Y and [1/3, 2/3] for Z</li><li>Create bins: <span>$[-∞, q₁, q₂, q₃, ∞]$</span> (4 categories) and <span>$[-∞, q₁, q₂, ∞]$</span> (3 categories)</li></ol><p><strong>See Also</strong></p><ul><li><code>ContinuousDataGenerator</code>: For continuous (multivariate normal) covariates</li><li><code>generate</code>: Call this method on generator to produce DataFrame</li></ul><p><strong>Notes</strong></p><ul><li>Covariates are categorical (sampled from multinomial distributions)</li><li>Outcomes are always categorical (3-4 classes based on quantile binning)</li><li>R² parameter controls signal-to-noise ratio in linear model</li><li>Scenario parameter allows testing covariate shift and distribution mismatch assumptions</li><li>Covariance matrices computed from sampled data may vary between generator instances</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/otrecoding/OptimalTransportDataIntegration.jl/blob/972b019290e46df9e35cbe73eb02472dab094ed6/src/generate_discrete_data.jl#L16">source</a></section></details></article><article><details class="docstring" open="true"><summary id="OptimalTransportDataIntegration.generate-Tuple{DiscreteDataGenerator}"><a class="docstring-binding" href="#OptimalTransportDataIntegration.generate-Tuple{DiscreteDataGenerator}"><code>OptimalTransportDataIntegration.generate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">generate(generator; eps)
</code></pre><p>Generate a synthetic dataset with discrete (categorical) covariates and categorical outcomes.</p><p>Samples new categorical covariates from multinomial distributions specified in generator, computes latent outcomes via linear model on covariate indicators, then discretizes into  categorical bins pre-computed during generator construction.</p><p><strong>Arguments</strong></p><ul><li><code>generator::DiscreteDataGenerator</code>: Pre-configured generator with binning thresholds and covariance estimates</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>eps::Float64</code>: Offset added to outcome Z binning thresholds (for covariate shift sensitivity); default: 0.0</li></ul><p><strong>Returns</strong></p><ul><li><code>DataFrame</code>: Dataset with columns:<ul><li><code>X1, X2, ...</code>: Categorical covariates (dimension matches <code>length(params.pA)</code>)</li><li><code>Y</code>: Categorical outcome (1:4) indicating base B&#39;s observed outcome</li><li><code>Z</code>: Categorical outcome (1:3) indicating base A&#39;s observed outcome</li><li><code>database</code>: Integer (1 for base A, 2 for base B) indicating data source</li><li>Total rows: <code>params.nA + params.nB</code></li></ul></li></ul><p><strong>Algorithm</strong></p><ol><li>Sample categorical covariates: XA[i,j] ~ Categorical(pA[j]) for each base independently</li><li>Compute latent outcomes: Y1 = XA&#39;·aA + ε<em>A and Y2 = XB&#39;·aB + ε</em>B</li><li>Digitize into categories using pre-computed bins:<ul><li>YA = digitize(Y1, binsYA), ZA = digitize(Y1, binsZA)</li><li>YB = digitize(Y2, binsYB + eps), ZB = digitize(Y2, binsZB + eps)</li></ul></li><li>Assemble DataFrame with database indicator</li><li>Log category distributions (info level)</li></ol><p><strong>Details</strong></p><ul><li><strong>Data split</strong>: Base A (database=1) has outcomes Z, Base B (database=2) has outcomes Y</li><li><strong>Missing outcomes</strong>: Implicit in database indicator (no NAs in columns)</li><li><strong>Outcome relationship</strong>: Z and Y in same base are derived from same latent variable</li><li><strong>eps parameter</strong>: Small perturbation useful for testing robustness to binning threshold changes</li><li><strong>Covariate sampling</strong>: Independent samples each call, so distributions may vary slightly from params</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">params = DataParameters(nA=500, nB=500, r2=0.6)
gen = DiscreteDataGenerator(params, scenario=1)
data = generate(gen)  # 1000 rows × 5 columns (3 covariates + Y + Z + database)</code></pre><p><strong>See Also</strong></p><ul><li><code>DiscreteDataGenerator</code>: Constructor with binning logic</li><li><code>ContinuousDataGenerator</code> / <code>generate</code>: Continuous covariates alternative</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/otrecoding/OptimalTransportDataIntegration.jl/blob/972b019290e46df9e35cbe73eb02472dab094ed6/src/generate_discrete_data.jl#L154">source</a></section></details></article><h2 id="Recoding-methods"><a class="docs-heading-anchor" href="#Recoding-methods">Recoding methods</a><a id="Recoding-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Recoding-methods" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="OptimalTransportDataIntegration.AbstractMethod"><a class="docstring-binding" href="#OptimalTransportDataIntegration.AbstractMethod"><code>OptimalTransportDataIntegration.AbstractMethod</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">AbstractMethod</code></pre><p>Abstract base type for all statistical matching methods.</p><p>All concrete methods (e.g., <code>JointOTWithinBase</code>, <code>SimpleLearning</code>) must inherit from this type and implement a corresponding <code>otrecod(data::DataFrame, method::YourMethod)</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/otrecoding/OptimalTransportDataIntegration.jl/blob/972b019290e46df9e35cbe73eb02472dab094ed6/src/otrecod.jl#L15-L22">source</a></section></details></article><article><details class="docstring" open="true"><summary id="OptimalTransportDataIntegration.JointOTBetweenBases"><a class="docstring-binding" href="#OptimalTransportDataIntegration.JointOTBetweenBases"><code>OptimalTransportDataIntegration.JointOTBetweenBases</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">JointOTBetweenBases &lt;: AbstractMethod</code></pre><p>Joint optimal transport between data sources with discrete outcomes.</p><p>Solves optimal transport problems that match the joint distribution of covariates and outcomes from base B to base A. Requires discrete (categorical) covariates.</p><p><strong>Fields</strong></p><ul><li><code>reg::Float64 = 0.001</code>: Entropy regularization parameter (0 = exact OT)</li><li><code>reg_m1::Float64 = 0.01</code>: Marginal constraint relaxation for first moment</li><li><code>reg_m2::Float64 = 0.01</code>: Marginal constraint relaxation for second moment</li><li><code>Ylevels::Vector{Int} = 1:4</code>: Discrete levels of outcome Y</li><li><code>Zlevels::Vector{Int} = 1:3</code>: Discrete levels of outcome Z</li><li><code>iterations::Int = 10</code>: Number of Sinkhorn iterations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/otrecoding/OptimalTransportDataIntegration.jl/blob/972b019290e46df9e35cbe73eb02472dab094ed6/src/otrecod.jl#L171-L186">source</a></section></details></article><article><details class="docstring" open="true"><summary id="OptimalTransportDataIntegration.JointOTBetweenBasesCategory"><a class="docstring-binding" href="#OptimalTransportDataIntegration.JointOTBetweenBasesCategory"><code>OptimalTransportDataIntegration.JointOTBetweenBasesCategory</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">JointOTBetweenBasesCategory &lt;: AbstractMethod</code></pre><p>Joint optimal transport between data sources with categorical outcomes.</p><p>Extension of <code>JointOTBetweenBases</code> using one-hot encoding for categorical outcomes. Enables better handling of discrete outcome distributions via explicit category representation.</p><p><strong>Fields</strong></p><ul><li><code>reg::Float64 = 0.001</code>: Entropy regularization parameter</li><li><code>reg_m1::Float64 = 0.01</code>: First moment marginal relaxation</li><li><code>reg_m2::Float64 = 0.01</code>: Second moment marginal relaxation</li><li><code>Ylevels::Vector{Int} = 1:4</code>: Categories of outcome Y</li><li><code>Zlevels::Vector{Int} = 1:3</code>: Categories of outcome Z</li><li><code>iterations::Int = 10</code>: Sinkhorn iterations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/otrecoding/OptimalTransportDataIntegration.jl/blob/972b019290e46df9e35cbe73eb02472dab094ed6/src/otrecod.jl#L240-L255">source</a></section></details></article><article><details class="docstring" open="true"><summary id="OptimalTransportDataIntegration.JointOTBetweenBasesJDOT"><a class="docstring-binding" href="#OptimalTransportDataIntegration.JointOTBetweenBasesJDOT"><code>OptimalTransportDataIntegration.JointOTBetweenBasesJDOT</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">JointOTBetweenBasesJDOT &lt;: AbstractMethod</code></pre><p>Joint Distribution Optimal Transport between continuous data sources.</p><p>Implements JDOT (Joint Distribution Optimal Transport) which simultaneously learns a classifier and aligns distributions between sources.</p><p><strong>Fields</strong></p><ul><li><code>reg::Float64 = 0.001</code>: OT entropy regularization</li><li><code>reg_m1::Float64 = 0.01</code>: First moment marginal relaxation</li><li><code>reg_m2::Float64 = 0.01</code>: Second moment marginal relaxation</li><li><code>Ylevels::Vector{Int} = 1:4</code>: Y categories</li><li><code>Zlevels::Vector{Int} = 1:3</code>: Z categories</li><li><code>iterations::Int = 10</code>: OT iterations</li><li><code>distance::Distances.Metric = Euclidean()</code>: Distance metric</li><li><code>hidden_layer_size::Int = 10</code>: Network hidden units</li><li><code>learning_rate::Float64 = 0.01</code>: Training rate</li><li><code>batchsize::Int = 64</code>: Batch size</li><li><code>epochs::Int = 1000</code>: Training epochs</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/otrecoding/OptimalTransportDataIntegration.jl/blob/972b019290e46df9e35cbe73eb02472dab094ed6/src/otrecod.jl#L390-L410">source</a></section></details></article><article><details class="docstring" open="true"><summary id="OptimalTransportDataIntegration.JointOTBetweenBasesWithPredictors"><a class="docstring-binding" href="#OptimalTransportDataIntegration.JointOTBetweenBasesWithPredictors"><code>OptimalTransportDataIntegration.JointOTBetweenBasesWithPredictors</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">JointOTBetweenBasesWithPredictors &lt;: AbstractMethod</code></pre><p>Hybrid method combining optimal transport with neural network predictors.</p><p>Combines OT-based covariate matching with neural networks to predict outcomes. Enables handling of both discrete and continuous covariates.</p><p><strong>Fields</strong></p><ul><li><code>reg::Float64 = 0.001</code>: OT entropy regularization</li><li><code>reg_m1::Float64 = 0.01</code>: Marginal relaxation (first moment)</li><li><code>reg_m2::Float64 = 0.01</code>: Marginal relaxation (second moment)</li><li><code>Ylevels::Vector{Int} = 1:4</code>: Y outcome categories</li><li><code>Zlevels::Vector{Int} = 1:3</code>: Z outcome categories</li><li><code>iterations::Int = 10</code>: Transport iterations</li><li><code>hidden_layer_size::Int = 10</code>: Neural network hidden layer size</li><li><code>learning_rate::Float64 = 0.01</code>: Learning rate for network training</li><li><code>batchsize::Int = 64</code>: Mini-batch size</li><li><code>epochs::Int = 1000</code>: Training epochs</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/otrecoding/OptimalTransportDataIntegration.jl/blob/972b019290e46df9e35cbe73eb02472dab094ed6/src/otrecod.jl#L309-L328">source</a></section></details></article><article><details class="docstring" open="true"><summary id="OptimalTransportDataIntegration.JointOTBetweenBasesWithoutOutcomes"><a class="docstring-binding" href="#OptimalTransportDataIntegration.JointOTBetweenBasesWithoutOutcomes"><code>OptimalTransportDataIntegration.JointOTBetweenBasesWithoutOutcomes</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">JointOTBetweenBasesWithoutOutcomes &lt;: AbstractMethod</code></pre><p>Statistical matching using OT without observed outcome variables.</p><p>Variant that performs matching based solely on covariate distributions when outcome variables are not fully observed. Uses domain adaptation to learn implicit outcome predictors.</p><p><strong>Fields</strong></p><ul><li><code>reg::Float64 = 0.001</code>: Entropy regularization</li><li><code>reg_m1::Float64 = 0.01</code>: First moment relaxation</li><li><code>reg_m2::Float64 = 0.01</code>: Second moment relaxation</li><li><code>Ylevels::Vector{Int} = 1:4</code>: Expected Y categories</li><li><code>Zlevels::Vector{Int} = 1:3</code>: Expected Z categories</li><li><code>iterations::Int = 10</code>: OT iterations</li><li><code>hidden_layer_size::Int = 10</code>: Implicit predictor network hidden size</li><li><code>learning_rate::Float64 = 0.01</code>: Training rate</li><li><code>batchsize::Int = 64</code>: Batch size</li><li><code>epochs::Int = 1000</code>: Training epochs</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/otrecoding/OptimalTransportDataIntegration.jl/blob/972b019290e46df9e35cbe73eb02472dab094ed6/src/otrecod.jl#L719-L738">source</a></section></details></article><article><details class="docstring" open="true"><summary id="OptimalTransportDataIntegration.JointOTDABetweenBasesCovariables"><a class="docstring-binding" href="#OptimalTransportDataIntegration.JointOTDABetweenBasesCovariables"><code>OptimalTransportDataIntegration.JointOTDABetweenBasesCovariables</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">JointOTDABetweenBasesCovariables &lt;: AbstractMethod</code></pre><p>Domain adaptation focusing on covariate alignment.</p><p>Approach emphasizing alignment of covariate distributions between sources using domain adaptation techniques combined with optimal transport.</p><p><strong>Fields</strong></p><ul><li><code>reg::Float64 = 0.001</code>: Entropy regularization</li><li><code>reg_m1::Float64 = 0.01</code>: First moment marginal relaxation</li><li><code>reg_m2::Float64 = 0.01</code>: Second moment marginal relaxation</li><li><code>Ylevels::Vector{Int} = 1:4</code>: Y categories</li><li><code>Zlevels::Vector{Int} = 1:3</code>: Z categories</li><li><code>distance::Distances.Metric = Euclidean()</code>: Metric for covariates</li><li><code>hidden_layer_size::Int = 10</code>: Adapter network hidden size</li><li><code>learning_rate::Float64 = 0.01</code>: Training rate</li><li><code>batchsize::Int = 64</code>: Batch size</li><li><code>epochs::Int = 1000</code>: Training epochs</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/otrecoding/OptimalTransportDataIntegration.jl/blob/972b019290e46df9e35cbe73eb02472dab094ed6/src/otrecod.jl#L474-L493">source</a></section></details></article><article><details class="docstring" open="true"><summary id="OptimalTransportDataIntegration.JointOTDABetweenBasesOutcomes"><a class="docstring-binding" href="#OptimalTransportDataIntegration.JointOTDABetweenBasesOutcomes"><code>OptimalTransportDataIntegration.JointOTDABetweenBasesOutcomes</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">JointOTDABetweenBasesOutcomes &lt;: AbstractMethod</code></pre><p>Domain adaptation focusing on outcome variable alignment.</p><p>Approach emphasizing alignment of outcome distributions between sources. Combines OT-based distribution matching with domain adaptation principles.</p><p><strong>Fields</strong></p><ul><li><code>reg::Float64 = 0.001</code>: Entropy regularization</li><li><code>reg_m1::Float64 = 0.01</code>: First moment relaxation</li><li><code>reg_m2::Float64 = 0.01</code>: Second moment relaxation</li><li><code>Ylevels::Vector{Int} = 1:4</code>: Y categories</li><li><code>Zlevels::Vector{Int} = 1:3</code>: Z categories</li><li><code>iterations::Int = 10</code>: OT iterations</li><li><code>distance::Distances.Metric = Euclidean()</code>: Covariate metric</li><li><code>hidden_layer_size::Int = 10</code>: Network hidden size</li><li><code>learning_rate::Float64 = 0.01</code>: Training rate</li><li><code>batchsize::Int = 64</code>: Batch size</li><li><code>epochs::Int = 1000</code>: Training epochs</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/otrecoding/OptimalTransportDataIntegration.jl/blob/972b019290e46df9e35cbe73eb02472dab094ed6/src/otrecod.jl#L555-L575">source</a></section></details></article><article><details class="docstring" open="true"><summary id="OptimalTransportDataIntegration.JointOTDABetweenBasesOutcomesWithPredictors"><a class="docstring-binding" href="#OptimalTransportDataIntegration.JointOTDABetweenBasesOutcomesWithPredictors"><code>OptimalTransportDataIntegration.JointOTDABetweenBasesOutcomesWithPredictors</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">JointOTDABetweenBasesOutcomesWithPredictors &lt;: AbstractMethod</code></pre><p>Domain adaptation with outcome alignment and integrated neural predictors.</p><p>Combines outcome distribution alignment, domain adaptation, and neural network-based outcome prediction. Fully hybrid approach suitable for continuous data.</p><p><strong>Fields</strong></p><ul><li><code>reg::Float64 = 0.001</code>: Entropy regularization</li><li><code>reg_m1::Float64 = 0.01</code>: First moment relaxation</li><li><code>reg_m2::Float64 = 0.01</code>: Second moment relaxation</li><li><code>Ylevels::Vector{Int} = 1:4</code>: Y categories</li><li><code>Zlevels::Vector{Int} = 1:3</code>: Z categories</li><li><code>iterations::Int = 10</code>: OT iterations</li><li><code>hidden_layer_size::Int = 10</code>: Predictor network hidden size</li><li><code>learning_rate::Float64 = 0.01</code>: Training rate</li><li><code>batchsize::Int = 64</code>: Batch size</li><li><code>epochs::Int = 1000</code>: Training epochs</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/otrecoding/OptimalTransportDataIntegration.jl/blob/972b019290e46df9e35cbe73eb02472dab094ed6/src/otrecod.jl#L638-L657">source</a></section></details></article><article><details class="docstring" open="true"><summary id="OptimalTransportDataIntegration.JointOTWithinBase"><a class="docstring-binding" href="#OptimalTransportDataIntegration.JointOTWithinBase"><code>OptimalTransportDataIntegration.JointOTWithinBase</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">JointOTWithinBase &lt;: AbstractMethod</code></pre><p>Statistical matching using within-base optimal transport balancing.</p><p>This method balances the joint distribution of covariates and outcomes within each data source separately before making predictions. It works with both discrete and continuous covariates.</p><p><strong>Fields</strong></p><ul><li><code>lambda::Float64 = 0.1</code>: Regularization parameter for transport plan</li><li><code>alpha::Float64 = 0.1</code>: Weight parameter for balancing</li><li><code>percent_closest::Float64 = 0.2</code>: Fraction of closest neighbors to consider</li><li><code>distance::Distances.Metric = Euclidean()</code>: Distance metric for covariate space</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/otrecoding/OptimalTransportDataIntegration.jl/blob/972b019290e46df9e35cbe73eb02472dab094ed6/src/otrecod.jl#L27-L40">source</a></section></details></article><article><details class="docstring" open="true"><summary id="OptimalTransportDataIntegration.SimpleLearning"><a class="docstring-binding" href="#OptimalTransportDataIntegration.SimpleLearning"><code>OptimalTransportDataIntegration.SimpleLearning</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">SimpleLearning &lt;: AbstractMethod</code></pre><p>Neural network-based statistical matching using Flux.jl.</p><p>Uses a feedforward neural network with one hidden layer to learn the relationship between covariates and outcomes. Simple baseline for comparison with optimal transport methods.</p><p><strong>Fields</strong></p><ul><li><code>hidden_layer_size::Int = 10</code>: Number of neurons in hidden layer</li><li><code>learning_rate::Float64 = 0.01</code>: Learning rate for optimization</li><li><code>batchsize::Int = 64</code>: Mini-batch size for training</li><li><code>epochs::Int = 1000</code>: Number of training epochs</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/otrecoding/OptimalTransportDataIntegration.jl/blob/972b019290e46df9e35cbe73eb02472dab094ed6/src/otrecod.jl#L101-L114">source</a></section></details></article><article><details class="docstring" open="true"><summary id="OptimalTransportDataIntegration.otrecod-Tuple{DataFrames.DataFrame, JointOTBetweenBasesCategory}"><a class="docstring-binding" href="#OptimalTransportDataIntegration.otrecod-Tuple{DataFrames.DataFrame, JointOTBetweenBasesCategory}"><code>OptimalTransportDataIntegration.otrecod</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">otrecod(data::DataFrame, method::JointOTBetweenBasesCategory)</code></pre><p>Apply joint OT with categorical outcome encoding.</p><p>Similar to <code>JointOTBetweenBases</code> but uses one-hot encoding for categorical outcomes, which can improve numerical stability and interpretability.</p><p><strong>Arguments</strong></p><ul><li><code>data::DataFrame</code>: Input data with discrete covariates</li><li><code>method::JointOTBetweenBasesCategory</code>: Configuration</li></ul><p><strong>Returns</strong></p><ul><li><code>JointOTResult</code>: Predictions and ground truth</li></ul><p><strong>Throws</strong></p><ul><li><code>AssertionError</code>: If covariates are not categorical</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/otrecoding/OptimalTransportDataIntegration.jl/blob/972b019290e46df9e35cbe73eb02472dab094ed6/src/otrecod.jl#L265-L282">source</a></section></details></article><article><details class="docstring" open="true"><summary id="OptimalTransportDataIntegration.otrecod-Tuple{DataFrames.DataFrame, JointOTBetweenBasesJDOT}"><a class="docstring-binding" href="#OptimalTransportDataIntegration.otrecod-Tuple{DataFrames.DataFrame, JointOTBetweenBasesJDOT}"><code>OptimalTransportDataIntegration.otrecod</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">otrecod(data::DataFrame, method::JointOTBetweenBasesJDOT)</code></pre><p>Apply JDOT for continuous data sources.</p><p>Simultaneously learns outcome predictions and aligns covariate distributions. Requires continuous covariates.</p><p><strong>Arguments</strong></p><ul><li><code>data::DataFrame</code>: Input data with continuous covariates</li><li><code>method::JointOTBetweenBasesJDOT</code>: JDOT configuration</li></ul><p><strong>Returns</strong></p><ul><li><code>JointOTResult</code>: Predictions and ground truth</li></ul><p><strong>Throws</strong></p><ul><li><code>AssertionError</code>: If covariates are discrete</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/otrecoding/OptimalTransportDataIntegration.jl/blob/972b019290e46df9e35cbe73eb02472dab094ed6/src/otrecod.jl#L427-L444">source</a></section></details></article><article><details class="docstring" open="true"><summary id="OptimalTransportDataIntegration.otrecod-Tuple{DataFrames.DataFrame, JointOTBetweenBasesWithPredictors}"><a class="docstring-binding" href="#OptimalTransportDataIntegration.otrecod-Tuple{DataFrames.DataFrame, JointOTBetweenBasesWithPredictors}"><code>OptimalTransportDataIntegration.otrecod</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">otrecod(data::DataFrame, method::JointOTBetweenBasesWithPredictors)</code></pre><p>Apply hybrid OT + neural network approach.</p><p>Combines transport plan computation with network-based outcome prediction. Works with both discrete and continuous covariates.</p><p><strong>Arguments</strong></p><ul><li><code>data::DataFrame</code>: Input data with outcomes</li><li><code>method::JointOTBetweenBasesWithPredictors</code>: Hybrid configuration</li></ul><p><strong>Returns</strong></p><ul><li><code>JointOTResult</code>: Predictions and ground truth</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/otrecoding/OptimalTransportDataIntegration.jl/blob/972b019290e46df9e35cbe73eb02472dab094ed6/src/otrecod.jl#L344-L358">source</a></section></details></article><article><details class="docstring" open="true"><summary id="OptimalTransportDataIntegration.otrecod-Tuple{DataFrames.DataFrame, JointOTBetweenBasesWithoutOutcomes}"><a class="docstring-binding" href="#OptimalTransportDataIntegration.otrecod-Tuple{DataFrames.DataFrame, JointOTBetweenBasesWithoutOutcomes}"><code>OptimalTransportDataIntegration.otrecod</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">otrecod(data::DataFrame, method::JointOTBetweenBasesWithoutOutcomes)</code></pre><p>Apply OT-based matching without explicit outcome observations.</p><p>Matches distributions and predicts outcomes using implicit predictors learned from covariate structure. Requires continuous covariates.</p><p><strong>Arguments</strong></p><ul><li><code>data::DataFrame</code>: Input data (outcomes may be partially missing)</li><li><code>method::JointOTBetweenBasesWithoutOutcomes</code>: Configuration</li></ul><p><strong>Returns</strong></p><ul><li><code>JointOTResult</code>: Predictions and ground truth</li></ul><p><strong>Throws</strong></p><ul><li><code>AssertionError</code>: If covariates are discrete</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/otrecoding/OptimalTransportDataIntegration.jl/blob/972b019290e46df9e35cbe73eb02472dab094ed6/src/otrecod.jl#L754-L771">source</a></section></details></article><article><details class="docstring" open="true"><summary id="OptimalTransportDataIntegration.otrecod-Tuple{DataFrames.DataFrame, JointOTBetweenBases}"><a class="docstring-binding" href="#OptimalTransportDataIntegration.otrecod-Tuple{DataFrames.DataFrame, JointOTBetweenBases}"><code>OptimalTransportDataIntegration.otrecod</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">otrecod(data::DataFrame, method::JointOTBetweenBases)</code></pre><p>Apply joint optimal transport between discrete data sources.</p><p>Requires covariates to be categorical. Matches distributions between bases and predicts missing outcomes using the transport map.</p><p><strong>Arguments</strong></p><ul><li><code>data::DataFrame</code>: Input data with discrete covariates and outcomes</li><li><code>method::JointOTBetweenBases</code>: OT configuration</li></ul><p><strong>Returns</strong></p><ul><li><code>JointOTResult</code>: Predictions and ground truth</li></ul><p><strong>Throws</strong></p><ul><li><code>AssertionError</code>: If covariates are not categorical</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/otrecoding/OptimalTransportDataIntegration.jl/blob/972b019290e46df9e35cbe73eb02472dab094ed6/src/otrecod.jl#L196-L213">source</a></section></details></article><article><details class="docstring" open="true"><summary id="OptimalTransportDataIntegration.otrecod-Tuple{DataFrames.DataFrame, JointOTDABetweenBasesCovariables}"><a class="docstring-binding" href="#OptimalTransportDataIntegration.otrecod-Tuple{DataFrames.DataFrame, JointOTDABetweenBasesCovariables}"><code>OptimalTransportDataIntegration.otrecod</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">otrecod(data::DataFrame, method::JointOTDABetweenBasesCovariables)</code></pre><p>Apply domain adaptation with covariate focus.</p><p>Aligns covariate distributions while learning outcome predictions. Requires continuous covariates.</p><p><strong>Arguments</strong></p><ul><li><code>data::DataFrame</code>: Input data with continuous covariates</li><li><code>method::JointOTDABetweenBasesCovariables</code>: DA configuration</li></ul><p><strong>Returns</strong></p><ul><li><code>JointOTResult</code>: Predictions and ground truth</li></ul><p><strong>Throws</strong></p><ul><li><code>AssertionError</code>: If covariates are discrete</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/otrecoding/OptimalTransportDataIntegration.jl/blob/972b019290e46df9e35cbe73eb02472dab094ed6/src/otrecod.jl#L509-L526">source</a></section></details></article><article><details class="docstring" open="true"><summary id="OptimalTransportDataIntegration.otrecod-Tuple{DataFrames.DataFrame, JointOTDABetweenBasesOutcomesWithPredictors}"><a class="docstring-binding" href="#OptimalTransportDataIntegration.otrecod-Tuple{DataFrames.DataFrame, JointOTDABetweenBasesOutcomesWithPredictors}"><code>OptimalTransportDataIntegration.otrecod</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">otrecod(data::DataFrame, method::JointOTDABetweenBasesOutcomesWithPredictors)</code></pre><p>Apply full domain adaptation with outcome alignment and predictors.</p><p>Integrates outcome distribution alignment with neural network prediction. Requires continuous covariates.</p><p><strong>Arguments</strong></p><ul><li><code>data::DataFrame</code>: Input data with continuous covariates</li><li><code>method::JointOTDABetweenBasesOutcomesWithPredictors</code>: Configuration</li></ul><p><strong>Returns</strong></p><ul><li><code>JointOTResult</code>: Predictions and ground truth</li></ul><p><strong>Throws</strong></p><ul><li><code>AssertionError</code>: If covariates are discrete</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/otrecoding/OptimalTransportDataIntegration.jl/blob/972b019290e46df9e35cbe73eb02472dab094ed6/src/otrecod.jl#L673-L690">source</a></section></details></article><article><details class="docstring" open="true"><summary id="OptimalTransportDataIntegration.otrecod-Tuple{DataFrames.DataFrame, JointOTDABetweenBasesOutcomes}"><a class="docstring-binding" href="#OptimalTransportDataIntegration.otrecod-Tuple{DataFrames.DataFrame, JointOTDABetweenBasesOutcomes}"><code>OptimalTransportDataIntegration.otrecod</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">otrecod(data::DataFrame, method::JointOTDABetweenBasesOutcomes)</code></pre><p>Apply domain adaptation with outcome focus.</p><p>Aligns outcome distributions while performing statistical matching. Requires continuous covariates.</p><p><strong>Arguments</strong></p><ul><li><code>data::DataFrame</code>: Input data with continuous covariates</li><li><code>method::JointOTDABetweenBasesOutcomes</code>: DA configuration</li></ul><p><strong>Returns</strong></p><ul><li><code>JointOTResult</code>: Predictions and ground truth</li></ul><p><strong>Throws</strong></p><ul><li><code>AssertionError</code>: If covariates are discrete</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/otrecoding/OptimalTransportDataIntegration.jl/blob/972b019290e46df9e35cbe73eb02472dab094ed6/src/otrecod.jl#L592-L609">source</a></section></details></article><article><details class="docstring" open="true"><summary id="OptimalTransportDataIntegration.otrecod-Tuple{DataFrames.DataFrame, JointOTWithinBase}"><a class="docstring-binding" href="#OptimalTransportDataIntegration.otrecod-Tuple{DataFrames.DataFrame, JointOTWithinBase}"><code>OptimalTransportDataIntegration.otrecod</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">otrecod(data::DataFrame, method::JointOTWithinBase)</code></pre><p>Apply within-base optimal transport balancing to match data sources.</p><p>Automatically detects if covariates are discrete or continuous and applies the appropriate algorithm. Returns predictions for missing outcomes (Y in base A, Z in base B).</p><p><strong>Arguments</strong></p><ul><li><code>data::DataFrame</code>: Input data with columns <code>database</code> (1 or 2), <code>X*</code> (covariates), <code>Y</code>, <code>Z</code> (outcomes)</li><li><code>method::JointOTWithinBase</code>: Method configuration</li></ul><p><strong>Returns</strong></p><ul><li><code>JointOTResult</code>: Tuple containing (yb<em>true, za</em>true, yb<em>pred, za</em>pred)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/otrecoding/OptimalTransportDataIntegration.jl/blob/972b019290e46df9e35cbe73eb02472dab094ed6/src/otrecod.jl#L50-L64">source</a></section></details></article><article><details class="docstring" open="true"><summary id="OptimalTransportDataIntegration.otrecod-Tuple{DataFrames.DataFrame, SimpleLearning}"><a class="docstring-binding" href="#OptimalTransportDataIntegration.otrecod-Tuple{DataFrames.DataFrame, SimpleLearning}"><code>OptimalTransportDataIntegration.otrecod</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">otrecod(data::DataFrame, method::SimpleLearning)</code></pre><p>Apply neural network-based learning for statistical matching.</p><p>Automatically routes to discrete or continuous implementation based on covariate types. Trains separate networks for each outcome variable.</p><p><strong>Arguments</strong></p><ul><li><code>data::DataFrame</code>: Input data with columns <code>database</code>, <code>X*</code>, <code>Y</code>, <code>Z</code></li><li><code>method::SimpleLearning</code>: Learning configuration</li></ul><p><strong>Returns</strong></p><ul><li><code>JointOTResult</code>: Predictions and ground truth values</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/otrecoding/OptimalTransportDataIntegration.jl/blob/972b019290e46df9e35cbe73eb02472dab094ed6/src/otrecod.jl#L124-L138">source</a></section></details></article><h2 id="Helper-functions"><a class="docs-heading-anchor" href="#Helper-functions">Helper functions</a><a id="Helper-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Helper-functions" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="OptimalTransportDataIntegration.accuracy"><a class="docstring-binding" href="#OptimalTransportDataIntegration.accuracy"><code>OptimalTransportDataIntegration.accuracy</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">accuracy(ypred, ytrue)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/otrecoding/OptimalTransportDataIntegration.jl/blob/972b019290e46df9e35cbe73eb02472dab094ed6/src/OptimalTransportDataIntegration.jl#L46">source</a></section><section><div><pre><code class="language-julia hljs">accuracy(data, yb_pred, za_pred)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/otrecoding/OptimalTransportDataIntegration.jl/blob/972b019290e46df9e35cbe73eb02472dab094ed6/src/OptimalTransportDataIntegration.jl#L51">source</a></section><section><div><pre><code class="language-julia hljs">accuracy(sol)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/otrecoding/OptimalTransportDataIntegration.jl/blob/972b019290e46df9e35cbe73eb02472dab094ed6/src/OptimalTransportDataIntegration.jl#L74">source</a></section></details></article><article><details class="docstring" open="true"><summary id="OptimalTransportDataIntegration.confusion_matrix"><a class="docstring-binding" href="#OptimalTransportDataIntegration.confusion_matrix"><code>OptimalTransportDataIntegration.confusion_matrix</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">confusion_matrix(y_true, y_pred; classes)
</code></pre><p>made by claude.ai</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/otrecoding/OptimalTransportDataIntegration.jl/blob/972b019290e46df9e35cbe73eb02472dab094ed6/src/OptimalTransportDataIntegration.jl#L87">source</a></section></details></article><article><details class="docstring" open="true"><summary id="OptimalTransportDataIntegration.compute_pred_error!"><a class="docstring-binding" href="#OptimalTransportDataIntegration.compute_pred_error!"><code>OptimalTransportDataIntegration.compute_pred_error!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">compute_pred_error!(sol, inst)
compute_pred_error!(sol, inst, proba_disp)
compute_pred_error!(sol, inst, proba_disp, mis_disp)
compute_pred_error!(
    sol,
    inst,
    proba_disp,
    mis_disp,
    full_disp
)
</code></pre><p>Compute prediction errors in a solution</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/otrecoding/OptimalTransportDataIntegration.jl/blob/972b019290e46df9e35cbe73eb02472dab094ed6/src/pred_error.jl#L3">source</a></section></details></article><ul><li><a href="#OptimalTransportDataIntegration.AbstractMethod"><code>OptimalTransportDataIntegration.AbstractMethod</code></a></li><li><a href="#OptimalTransportDataIntegration.ContinuousDataGenerator"><code>OptimalTransportDataIntegration.ContinuousDataGenerator</code></a></li><li><a href="#OptimalTransportDataIntegration.DataParameters"><code>OptimalTransportDataIntegration.DataParameters</code></a></li><li><a href="#OptimalTransportDataIntegration.DiscreteDataGenerator"><code>OptimalTransportDataIntegration.DiscreteDataGenerator</code></a></li><li><a href="joint_ot_within_base/#OptimalTransportDataIntegration.Instance"><code>OptimalTransportDataIntegration.Instance</code></a></li><li><a href="#OptimalTransportDataIntegration.JointOTBetweenBases"><code>OptimalTransportDataIntegration.JointOTBetweenBases</code></a></li><li><a href="#OptimalTransportDataIntegration.JointOTBetweenBasesCategory"><code>OptimalTransportDataIntegration.JointOTBetweenBasesCategory</code></a></li><li><a href="#OptimalTransportDataIntegration.JointOTBetweenBasesJDOT"><code>OptimalTransportDataIntegration.JointOTBetweenBasesJDOT</code></a></li><li><a href="#OptimalTransportDataIntegration.JointOTBetweenBasesWithPredictors"><code>OptimalTransportDataIntegration.JointOTBetweenBasesWithPredictors</code></a></li><li><a href="#OptimalTransportDataIntegration.JointOTBetweenBasesWithoutOutcomes"><code>OptimalTransportDataIntegration.JointOTBetweenBasesWithoutOutcomes</code></a></li><li><a href="#OptimalTransportDataIntegration.JointOTDABetweenBasesCovariables"><code>OptimalTransportDataIntegration.JointOTDABetweenBasesCovariables</code></a></li><li><a href="#OptimalTransportDataIntegration.JointOTDABetweenBasesOutcomes"><code>OptimalTransportDataIntegration.JointOTDABetweenBasesOutcomes</code></a></li><li><a href="#OptimalTransportDataIntegration.JointOTDABetweenBasesOutcomesWithPredictors"><code>OptimalTransportDataIntegration.JointOTDABetweenBasesOutcomesWithPredictors</code></a></li><li><a href="#OptimalTransportDataIntegration.JointOTWithinBase"><code>OptimalTransportDataIntegration.JointOTWithinBase</code></a></li><li><a href="#OptimalTransportDataIntegration.SimpleLearning"><code>OptimalTransportDataIntegration.SimpleLearning</code></a></li><li><a href="joint_ot_within_base/#OptimalTransportDataIntegration.Solution"><code>OptimalTransportDataIntegration.Solution</code></a></li><li><a href="#OptimalTransportDataIntegration.accuracy"><code>OptimalTransportDataIntegration.accuracy</code></a></li><li><a href="joint_ot_within_base/#OptimalTransportDataIntegration.average_distance_to_closest-Tuple{Instance, Float64}"><code>OptimalTransportDataIntegration.average_distance_to_closest</code></a></li><li><a href="#OptimalTransportDataIntegration.compute_pred_error!"><code>OptimalTransportDataIntegration.compute_pred_error!</code></a></li><li><a href="#OptimalTransportDataIntegration.confusion_matrix"><code>OptimalTransportDataIntegration.confusion_matrix</code></a></li><li><a href="#OptimalTransportDataIntegration.generate-Tuple{ContinuousDataGenerator}"><code>OptimalTransportDataIntegration.generate</code></a></li><li><a href="#OptimalTransportDataIntegration.generate-Tuple{DiscreteDataGenerator}"><code>OptimalTransportDataIntegration.generate</code></a></li><li><a href="joint_ot_between_bases/#OptimalTransportDataIntegration.joint_ot_between_bases_category-NTuple{4, Any}"><code>OptimalTransportDataIntegration.joint_ot_between_bases_category</code></a></li><li><a href="joint_ot_between_bases/#OptimalTransportDataIntegration.joint_ot_between_bases_da_covariables-Tuple{Any}"><code>OptimalTransportDataIntegration.joint_ot_between_bases_da_covariables</code></a></li><li><a href="joint_ot_between_bases/#OptimalTransportDataIntegration.joint_ot_between_bases_da_outcomes-Tuple{Any}"><code>OptimalTransportDataIntegration.joint_ot_between_bases_da_outcomes</code></a></li><li><a href="joint_ot_between_bases/#OptimalTransportDataIntegration.joint_ot_between_bases_da_outcomes_with_predictors-Tuple{Any}"><code>OptimalTransportDataIntegration.joint_ot_between_bases_da_outcomes_with_predictors</code></a></li><li><a href="joint_ot_between_bases/#OptimalTransportDataIntegration.joint_ot_between_bases_discrete-NTuple{4, Any}"><code>OptimalTransportDataIntegration.joint_ot_between_bases_discrete</code></a></li><li><a href="joint_ot_between_bases/#OptimalTransportDataIntegration.joint_ot_between_bases_jdot-Tuple{Any}"><code>OptimalTransportDataIntegration.joint_ot_between_bases_jdot</code></a></li><li><a href="joint_ot_between_bases/#OptimalTransportDataIntegration.joint_ot_between_bases_with_predictors-Tuple{Any}"><code>OptimalTransportDataIntegration.joint_ot_between_bases_with_predictors</code></a></li><li><a href="joint_ot_between_bases/#OptimalTransportDataIntegration.joint_ot_between_bases_without_outcomes-Tuple{Any}"><code>OptimalTransportDataIntegration.joint_ot_between_bases_without_outcomes</code></a></li><li><a href="joint_ot_within_base/#OptimalTransportDataIntegration.joint_ot_within_base_continuous-Tuple{Any}"><code>OptimalTransportDataIntegration.joint_ot_within_base_continuous</code></a></li><li><a href="learning/#OptimalTransportDataIntegration.learning_with_continuous_data-Tuple{Any}"><code>OptimalTransportDataIntegration.learning_with_continuous_data</code></a></li><li><a href="learning/#OptimalTransportDataIntegration.onehot-Tuple{AbstractMatrix}"><code>OptimalTransportDataIntegration.onehot</code></a></li><li><a href="joint_ot_within_base/#OptimalTransportDataIntegration.ot_joint-Tuple{Instance, Float64, Float64, Float64}"><code>OptimalTransportDataIntegration.ot_joint</code></a></li><li><a href="#OptimalTransportDataIntegration.otrecod-Tuple{DataFrames.DataFrame, JointOTBetweenBases}"><code>OptimalTransportDataIntegration.otrecod</code></a></li><li><a href="#OptimalTransportDataIntegration.otrecod-Tuple{DataFrames.DataFrame, JointOTDABetweenBasesOutcomes}"><code>OptimalTransportDataIntegration.otrecod</code></a></li><li><a href="#OptimalTransportDataIntegration.otrecod-Tuple{DataFrames.DataFrame, SimpleLearning}"><code>OptimalTransportDataIntegration.otrecod</code></a></li><li><a href="#OptimalTransportDataIntegration.otrecod-Tuple{DataFrames.DataFrame, JointOTBetweenBasesCategory}"><code>OptimalTransportDataIntegration.otrecod</code></a></li><li><a href="#OptimalTransportDataIntegration.otrecod-Tuple{DataFrames.DataFrame, JointOTBetweenBasesJDOT}"><code>OptimalTransportDataIntegration.otrecod</code></a></li><li><a href="#OptimalTransportDataIntegration.otrecod-Tuple{DataFrames.DataFrame, JointOTDABetweenBasesCovariables}"><code>OptimalTransportDataIntegration.otrecod</code></a></li><li><a href="#OptimalTransportDataIntegration.otrecod-Tuple{DataFrames.DataFrame, JointOTWithinBase}"><code>OptimalTransportDataIntegration.otrecod</code></a></li><li><a href="#OptimalTransportDataIntegration.otrecod-Tuple{DataFrames.DataFrame, JointOTDABetweenBasesOutcomesWithPredictors}"><code>OptimalTransportDataIntegration.otrecod</code></a></li><li><a href="#OptimalTransportDataIntegration.otrecod-Tuple{DataFrames.DataFrame, JointOTBetweenBasesWithPredictors}"><code>OptimalTransportDataIntegration.otrecod</code></a></li><li><a href="#OptimalTransportDataIntegration.otrecod-Tuple{DataFrames.DataFrame, JointOTBetweenBasesWithoutOutcomes}"><code>OptimalTransportDataIntegration.otrecod</code></a></li><li><a href="#OptimalTransportDataIntegration.read-Tuple{AbstractString}"><code>OptimalTransportDataIntegration.read</code></a></li><li><a href="#OptimalTransportDataIntegration.save-Tuple{AbstractString, DataParameters}"><code>OptimalTransportDataIntegration.save</code></a></li><li><a href="learning/#OptimalTransportDataIntegration.simple_learning-Tuple{Any}"><code>OptimalTransportDataIntegration.simple_learning</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="joint_ot_within_base/">Transport within a data source »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Thursday 8 January 2026 14:30">Thursday 8 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
